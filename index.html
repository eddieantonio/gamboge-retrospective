<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Hacking Atom</title>

    <meta name="description" content="@eddieantonio's retrospective on writing a package for Atom">
    <meta name="author" content="Eddie Antonio Santos">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css" id="theme">
    <style>
      /* listing the class twice bumps up the specificity by MAGIC! */
      .atom-logo.atom-logo {
        /* Reposition it. */
        position: relative;
        bottom: -0.3em;

        /* Override all of the things! */
        max-height: 1em;
        background: transparent;
        border: 0;
        box-shadow: none;
      }

      .gamboge {
        color: #E49B0F;
      }

      .blurry-overlay {
        background-color: rgba(0, 0, 0, 0.7);
        padding: 2em;
        box-shadow: 0 0 120px 70px rgba(0,0,0,0.7)
      }

      img.haunter.haunter {
        position: absolute;
        top: 0.5em;
        left: -5em;
        z-index: -10;
        opacity: 0.2;
      }

      img.no-border.no-border {
        background: transparent;
        border: none;
        box-shadow: none;
      }
    </style>


    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <!-- TODO: Rewrite script for naturalness especially! -->
    <div class="reveal">
      <div class="slides">
        <!-- INTRODUCTION -->
        <section>
          <h1>Hacking <img class="atom-logo" alt="" src="images/atom-logo.png">Atom</h1>
          <h3>My experience writing an NLP-powered code suggestion engine</h3>
          <p>
            <small>By <a href="http://eddieantonio.ca/">Eddie Antonio Santos</a> / <a href="http://twitter.com/_eddieantonio">@_eddieantonio</a></small>
          </p>
          <aside class="notes">
              Hey ya'll. I'm eddieantonio. Last year I wrote a plugin for
              GitHub's Atom editor For SCIENCE! (Pre 1.0).

              How many people don't know what Atom is?

              Okay, so Atom is like Sublime Text, but in JavaScript. It's
              meant to be a web-technology powered editor, and at the time of
              writing this plugin, it was... okay.

              And I'm a tell you
              all about it. But first...  </aside>
        </section>

        <!-- RESEARCH -->
        <!--
          TODO: No longer assume that people know what Atom is.... or
          NLP... or code suggestion... or other tokens...
          or n-gram language models
        -->
        <section>
          <section
            data-background="http://i.imgur.com/ENrwNJY.jpg"
            data-background-repeat="no-repeat" >
            <div class="blurry-overlay">
              <h2> Let me tell you about my research! </h2>
            </div>
            <aside class="notes">
              Let me tell you about my research!
            </aside>
          </section>

          <section>
            <h2> Naturalness of Software </h2>
            <!-- Abram Collaborators... etc. -->
            <aside class="notes">
              Way back in the halcyon days of 2012, Abram Hindle and his
              collaborators sought to find the answer to one question. It's
              based on the premise that natural language processing tools ---
              tools for analyzing language produced by actual human beings --
              therefore, natural, have been used successfully on natural
              language --
            </aside>
          </section>

          <section>
            <h2> Natural Language Processing </h2>
            <h3 class="fragment"> $n$-gram language model </h3>
            <aside class="notes">
            <!-- touch this text up... -->
              That is, the language that humans produce and use to
              communicated with each other.

              Why use n-gram models? Because it's easy! You don't need very
              knowledge of the programming language, and you don't need a lot
              of static analysis, especially that which would be difficult to
              pull off in real-time (for example, in JavaScript).

              An n-gram language model counts how many times a string of
              tokens has been seen in some training data, called its corpus.
              The n of n-gram denotes the order of the language model, or how
              many contiguous tokens are counted in the language model.

              Natural language tends to exhibits regularity and
              repetitiveness.

              But wait a minute... Language is
              a natural product of humans; and software is a product made by
              humans....
            </aside>
          </section>

          <section>
            <h2> Can natural language processing be successfully applied to software? </h2>
            <aside class="notes">
              Can natural language processing be successfully applied to software?
            </aside>
          </section>

          <section>
            <h1> Yes, probably. </h1>
          </section>

          <!--
          <section>
            <h2> <a style="color: white" href="https://youtu.be/sIlNIVXpIns">Look at this graph!</a> </h2>
            <iframe src="//www.slideshare.net/slideshow/embed_code/42840540" width="445" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:3px solid #666; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>
            <aside class="notes">
              (COPY RESULTS OF ABRAM'S PAPER.)
              This graph shows that using n-gram language models, they're less
              surprised with themselves on code than they are with English.
            </aside>
          </section>
          -->

          <section>
            <h2> A veritable buttload of applications! </h2>
            <!-- Extol the virtues of naturalness -->
              <!-- UnnaturalCode -->
              <!-- Mining source code idioms -->
              <!-- Localness -->
              <!-- Add more applications -->
            <ul>
              <li> Pinpointing syntax errors and bugs </li>
              <li> Mining source code idioms </li>
              <li> Better models taking locality into account </li>
              <li> Code completion and suggestion </li>
            </ul>
            <aside class="notes"> There are a TONNE of applications of the
              naturalness of software. Our colleague enhanced compilation
              errors for syntax errors, giving a better idea of where the
              error actually is than the compiler. We can also mine source
              code idioms a.k.a. snippets, and never have to manually create
              snippet templates ever again!  But it's this last one, code
              completion and suggestion that I want to talk about. </aside>
          </section>


        </section>

        <!-- Introduction to Gamboge -->
        <section>
          <section>
            <h2> Enter: <span class="gamboge">Gamboge</span> </h2>
            <h3 class="fragment"> Multitoken code suggestion in Atom </h3>

            <aside class="notes">
              Enter: Gamboge.

              Gamboge improves upon the methods made by Hindle et al. and Tu
              et al. by providing multi-token code suggestion. That is, it
              doesn't just predict one word or punctuation in advance; it
              predicts as many as it possibly can, exploiting the fact that
              code tends to be general.
            </aside>
          </section>

          <section>
            <img class="stretch" src="https://cdn.rawgit.com/eddieantonio/atom-gamboge/gh-pages/img/gamboge-0.1.0.gif" alt="Gamboge in action!">

            <aside class="notes">
              Here is an animated / ía…™f/ of Gamboge predicting Python code.

              [ad lib about multi-token prediction, whitespace prediction].

              It's secret for producing multiple tokens is sorting suggestions
              using mean surprise!
            </aside>
          </section>

          <section data-background=>
            <h2> Mean Surprise </h2>
            <img class="haunter no-border" src="about:blank" alt="Haunter" data-src="images/haunter.png" />
            <div class="fragment" style="margin: 1em; font-size: 3em">
              $$S_{i} = \frac{I_{i}}{|t_{i}|}$$
            </div>
            <h3 class="fragment"> (Steal this!) </h3>

            <aside class="notes">
              In an n-gram language model, we care about the surprisal of a
              sequence of tokens. It's literally just that: given some tokens,
              how surprising is it relative to the language model?

              This give us an intuitive way at looking at the next token's
              probability. The most probable token following some sequence is
              the least surprising token after the sequence.  Indeed, we call
              this measure the surprise of the token sequence. An event that
              is certain to happen, would have a probability of 100%. It is
              ‚Äúnot surprising‚Äù, so its surprisal value is 0. Similarly, an
              impossible event (according to our model) would leave us
              ‚Äúinfinitely surprised‚Äù.

              Adding another token to a suggestion will almost always
              increases the overall surprisal of the suggestion (unless that
              next token follows the last 100% of the time). So, how do we
              prioritize longer, but more useful suggestions? Instead of
              sorting suggestions based on the surprisal of the entire
              suggestion, we'll sort it according to the average, or mean
              surprise of the entire suggestion. This means for single token
              suggestions, its surprisal doesn't change. But for multitoken
              suggestions, where some tokens contribute very little to the
              surprisal of the suggestion, the longer suggestion is given.

              $S_{i}$ is the rank of suggestion $i$. $I_{i}$ here is the
              surprisal of all of the tokens in this suggestion. Therefore,
              just divide the total of tokens in the suggestion and we get an
              arithmetic mean.

              (A thought occurs: do we want mean surprise or mean probability?
              Because, mean probability would require log transforming...).

              It's effectiveness is left as an exercise for the reader...
            </aside>
          </section>

        </section>

        <section>
          <section>
            <h2> Lessons Learned </h2>
          </section>
          <section>
            <h2> It's just JavaScript (&amp; npm!)</h2>

            <div class="fragment">
              <a href="http://electron.atom.io/"><img
                class="no-border"
                data-src="http://electron.atom.io/images/electron-logo.svg"
                src="about:blank" alt="Electron" /></a>
            </div>

            <aside class="notes">
              Atom Electron (formerly known as Atom Shell ) is basically the
              Chromium smushed together with Node.js.  It's pretty rad! And
              you can use it independently of Atom to make desktop apps in
              HTML and Javascript. No bundler (Browserify, WebPack) required.

              Does anybosdy use Slack? Slack is made using Electron!

              You can just use npm and `require` like normal, which grants you
              one of the best parts of javascript. Plus it has most front-end
              libraries, incluing React and jQuery.

              That said, it's React. So don't touch the DOM!
            </aside>
          </section>

          <section>
            <h2> The Atom Community is... uh... </h2>

            <aside class="notes">
              Disclaimer: this is my personal opinion. Your milage may
              vary! The Atom community is kind of...  interesting.

              So, I'm one of those obnoxious people that overuses emoji. But
              even I have to draw the line when I saw this in their official
              CONTRIBUTING.md.
            </aside>
          </section>

          <!-- emoji style guide -->
          <section>
            <h3>Interesting priorities</h3>

            <a href="https://github.com/atom/atom/blob/master/CONTRIBUTING.md#git-commit-messages">
              <img data-src="images/emoji-style.png" src="about:blank"
                  alt="Emoji style guide">
            </a>

            <aside class="notes">
              It's a commit message emoji guide. And they're buttfucking
              serious about it.
            </aside>
          </section>

          <!-- flamewar -->
          <section>
            <h3>CoffeeScript</h3>

            <a href="https://discuss.atom.io/t/why-coffeescript/131">Anyone
              down for a flamewar?</a>

            <aside class="notes">
              Remember that part where I said it was just JavaScript? I lied.
              It's just CoffeeScript. It'd be pointless for me to comment
              about CoffeeScript itself; but the community's steadfast
              insistence to the language is... a bit baffling.  Anything that
              compiles to JavaScript will work... that is, everything ever.

              And yet they start flamewars on this issue.

              The fact that this happens in a post-ES6 world seems
              problematic to me.
            </aside>
          </section>


          <!-- this guy -->

          <!--section>
            <a href="http://atomio.discourse.org/t/why-only-jasmine-1-3/19047/4">
              <img src="about:blank" alt=":/" data-src="images/lee-dohm.png" />
            </a>

            <aside class="notes">
              This just pissed me off.
            </aside>
          </section-->

          <section>
            <h2> The Atom Community is... uh... </h2>

            <!--- using tags for formatting like it's 1998! -->
            <h1 style='font-family: "Apple Color Emoji", sans-serif;' class="fragment">üí©</h1>

            <aside class="notes">
              So the Atom Community is... yeah.
            </aside>
          </section>

          <section>
            <h2> Atom's Syntax Highligting Tokenizer </h2>
            <h3 class="fragment"> Insufficient for prediction! </h3>
            <code style="white-space: pre" class="fragment"><a href="http://esprima.org/doc/index.html">require('esprima').tokenize('const hello = `world`');</a></code>

            <aside class="notes">
              Earlier, I mentioned that all you need for an n-gram are those
              precious, precious tokens; basically, a syntax highlighter
              should probably have a good idea of what tokens are in a
              language if it's going to highlight it. That said, using the
              tokens from the syntax highlighter is insufficient; its regular
              expressions often groups tokens together, or add whitespace to
              the defintion of a token that would otherwise lack it.
              Additionally, it knows nothing of the INDENT and DEDENT tokens
              in whitespace sensitive langauges (Python, Haskell, YAML,
              CoffeeScript), so it's completely useless for these langauges.

              Luckily, one can use an external tool Esprima to do the
              tokenization for you.
            </aside>
          </section>


          <section>
            <h2> Relying on Pre 1.0 APIs </h2>
            <h3 class="fragment"> BAD IDEA </h3>

            <aside class="notes">
              I'd often get the rug pulled out underneath me as APIs were
              constantly changing. Not to mention the API docs were... lacking
              at best. I actually started a pull request to improve their docs
              for writing tests, and documenting the monkey-patching they did
              to make tests happen; but I ultimately did not complete it.

              At this point, I didn't know what React was, so I went ahead and
              modifed the DOM by hand. It's just JavaScript! But then they
              updated their React version which added aggressive checking of
              DOM invariants and inevitablly broke Gamboge. Gamboge has stayed
              in this state FOREVER.

              Speaking of tests...

              Also, the Vim-Mode was shit, and I actually learned plugin
              develpoing from having to patch the Vim-mode and <a
                href="https://github.com/atom/vim-mode/pull/410">make a PR</a>.
            </aside>
          </section>

          <section>
            <h2> Asynchronous testing in Jasmine 1.x </h2>
            <h3 class="fragment"> BAD IDEA </h3>

            <aside class="notes">

              In Atom, there's not good way to use any other testing framework
              than Jasmine 1.3. That's it. It's bundled in.

              The testing facillities are pretty cool; you can fully script
              the editor.  Really neat! But a lot of my tests involved
              asynchronous code.  Who has tested asynchronous code in Jasmine
              prior to version 2?  It's a bad idea. It's clunky, and
              problematic. This was the source of much frustration.
            </aside>
          </section>
        </section>

        <section>
          <h2> Conclusion </h2>

          <aside class="notes">

            While there a few problem with Atom, if you're willing to put up
            with the mild absurdity of the community, its use of modern web-technologies
            makes it an incredible platform for making attractive text editor
            plugins.

            The state of Atom *has* improved, and the fact that it's at 1.0
            means the API is moderatly stable; you shouldn't have the same
            problems as I did.

            And if you don't like Atom itself, you can make your own text
            editor using Atom Electron.
          </aside>
        </section>

        <!-- THE END -->
        <section>
          <section>
            <h2>Resources</h2>
            <h3> Natural Language Processing </h3>
            <ul>
              <li>
                <a href="https://class.coursera.org/nlp/lecture">Stanford NLP Lectures</a>
              </li>
              <li>
                <a href="https://github.com/NaturalNode/natural">NaturalNode</a>
              </li>
              <li>
                <a href="http://www.nltk.org/">NLTK (Python)</a>
              </li>
            </ul>
          </section>

          <section>
            <h2>Resources</h2>
            <h3> Language Tools </h3>
            <ul>
              <li>
                <a href="http://esprima.org/">Esprima</a>
              </li>
              <li>
                <a href="https://github.com/estools/escodegen">escodegen</a>
              </li>
            </ul>
          </section>
        </section>

        <section>
          <h2> Special Thanks </h2>
          <ul>
            <li><a href="http://softwareprocess.es/">Abram Hindle</a></li>
            <li><a href="http://orezpraw.com/">Joshua Charles Campbell</a></li>
            <li><a href="http://hipposociety.com/">Alex Wilson</a></li>
          </ul>
        </section>
      </div>
    </div>


    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: false,
      progress: false,
      history: true,
      center: true,

      transition: 'slide', // none/fade/slide/convex/concave/zoom

      // Optional reveal.js plugins
      dependencies: [
        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: 'plugin/zoom-js/zoom.js', async: true },
        { src: 'plugin/notes/notes.js', async: true },
        // MathJax
        { src: 'plugin/math/math.js', async: true }
      ]
    });

    </script>

  </body>
</html>
