<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Hacking Atom</title>

    <meta name="description" content="@eddieantonio's retrospective on writing a package for Atom">
    <meta name="author" content="Eddie Antonio Santos">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css" id="theme">
    <style>
      /* listing the class twice bumps up the specificity by MAGIC! */
      .atom-logo.atom-logo {
        /* Reposition it. */
        position: relative;
        bottom: -0.3em;

        /* Override all of the things! */
        max-height: 1em;
        background: transparent;
        border: 0;
        box-shadow: none;
      }

      .gamboge {
        color: #E49B0F;
      }

      .blurry-overlay {
        background-color: rgba(0, 0, 0, 0.7);
        padding: 2em;
        box-shadow: 0 0 120px 70px rgba(0,0,0,0.7)
      }

      img.haunter.haunter {
        background: transparent;
        border: none;
        box-shadow: none;
        position: absolute;
        top: 0.5em;
        left: -5em;
        z-index: -10;
        opacity: 0.2;
      }
    </style>


    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">
      <div class="slides">
        <!-- INTRODUCTION -->
        <section>
          <h1>Hacking <img class="atom-logo" alt="" src="images/atom-logo.png">Atom</h1>
          <h3>My experience writing an NLP-powered code suggestion engine</h3>
          <p>
            <small>By <a href="http://eddieantonio.ca/">Eddie Antonio Santos</a> / <a href="http://twitter.com/_eddieantonio">@_eddieantonio</a></small>
          </p>
          <aside class="notes">
              Hey ya'll. I'm eddieantonio. Last year I wrote a plugin for
              GitHub's Atom editor For SCIENCE! (Pre 1.0).

              How many people don't know what Atom is?

              Okay, so Atom is like Sublime Text, but in JavaScript. It's
              meant to be a web-technology powered editor, and at the time of
              writing this plugin, it was... okay.

              And I'm a tell you
              all about it. But first...  </aside>
        </section>

        <!-- RESEARCH -->
        <!--
          TODO: No longer assume that people know what Atom is.... or
          NLP... or code suggestion... or other tokens...
          or n-gram language models
        -->
        <section>
          <section
            data-background="http://i.imgur.com/ENrwNJY.jpg"
            data-background-repeat="no-repeat" >
            <div class="blurry-overlay">
              <h2> Let me tell you about my research! </h2>
            </div>
            <aside class="notes">
              Let me tell you about my research!
            </aside>
          </section>

          <section>
            <h2> Naturalness of Software </h2>
            <!-- Abram Collaborators... etc. -->
            <aside class="notes">
              Way back in the halcyon days of 2012, Abram Hindle and his
              collaborators sought to find the answer to one question. It's
              based on the premise that natural language processing tools ---
              tools for analyzing language produced by actual human beings --
              therefore, natural, have been used successfully on natural
              language --
            </aside>
          </section>

          <section>
            <h2> Natural Language Processing </h2>
            <h3> $n$-gram language model </h3>
            <aside class="notes">
            <!-- touch this text up... -->
              That is, the language that humans produce and use to
              communicated with each other.

              Why use n-gram models? Because it's easy! You don't need very
              knowledge of the programming language, and you don't need a lot
              of static analysis, especially that which would be difficult to
              pull off in real-time (for example, in JavaScript).

              Natural language tends to exhibits regularity and
              repetitiveness.

              But wait a minute... Language is
              a natural product of humans; and software is a product made by
              humans....
            </aside>
          </section>

          <section>
            <h2> Can natural language processing be successfully applied to software? </h2>
            <aside class="notes">
              Can natural language processing be successfully applied to software?
            </aside>
          </section>

          <section>
            <h1> Yes, probably. </h1>
          </section>

          <!--
          <section>
            <h2> <a style="color: white" href="https://youtu.be/sIlNIVXpIns">Look at this graph!</a> </h2>
            <iframe src="//www.slideshare.net/slideshow/embed_code/42840540" width="445" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:3px solid #666; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>
            <aside class="notes">
              (COPY RESULTS OF ABRAM'S PAPER.)
              This graph shows that using n-gram language models, they're less
              surprised with themselves on code than they are with English.
            </aside>
          </section>
          -->

          <section>
            <h2> A veritable butt-tonne of applications! </h2>
            <!-- Extol the virtues of naturalness -->
              <!-- UnnaturalCode -->
              <!-- Mining source code idioms -->
              <!-- Localness -->
            <ul>
              <li> Pinpointing syntax errors and bugs </li>
              <li> Mining source code idioms </li>
              <li> Better models taking locality into account </li>
              <li> Code completion and suggestion </li>
            </ul>
            <aside class="notes"> There are a TONNE of applications of the
              naturalness of software. Our colleague enhanced compilation
              errors for syntax errors, giving a better idea of where the
              error actually is than the compiler. We can also mine source
              code idioms a.k.a. snippets, and never have to manually create
              snippet templates ever again!  But it's this last one, code
              completion and suggestion that I want to talk about. </aside>
          </section>


        </section>

        <!-- Introduction to Gamboge -->
        <section>
          <section>
            <h2> Enter: <span class="gamboge">Gamboge</span> </h2>
            <h3 class="fragment"> Multitoken code suggestion in Atom </h3>

            <aside class="notes">
              Enter: Gamboge.

              Gamboge improves upon the methods made by Hindle et al. and Tu
              et al. by providing multi-token code suggestion. That is, it
              doesn't just predict one word or punctuation in advance; it
              predicts as many as it possibly can, exploiting the fact that
              code tends to be general.
            </aside>
          </section>

          <section>
            <img class="stretch" src="https://cdn.rawgit.com/eddieantonio/atom-gamboge/gh-pages/img/gamboge-0.1.0.gif" alt="Gamboge in action!">

            <aside class="notes">
              Here is an animated /ʒaɪf/ of Gamboge predicting Python code.

              [ad lib about multi-token prediction, whitespace prediction].

              It's secret for producing multiple tokens is sorting suggestions
              using mean surprise!
            </aside>
          </section>

          <section data-background=>
            <h2> Mean Surprise </h2>
            <img class="haunter" src="about:blank" alt="Haunter" data-src="images/haunter.png" />
            <div class="fragment" style="margin: 1em; font-size: 3em">
              $$S_{i} = \frac{I_{i}}{|t_{i}|}$$
            </div>
            <h3 class="fragment"> (Steal this!) </h3>

            <aside class="notes">
              In an n-gram language model, we care about the surprisal of a
              sequence of tokens. It's literally just that: given some tokens,
              how surprising is it relative to the language model?

              This give us an intuitive way at looking at the next token's
              probability. The most probable token following some sequence is
              the least surprising token after the sequence.  Indeed, we call
              this measure the surprise of the token sequence. An event that
              is certain to happen, would have a probability of 100%. It is
              “not surprising”, so its surprisal value is 0. Similarly, an
              impossible event (according to our model) would leave us
              “infinitely surprised”.

              Adding another token to a suggestion will almost always
              increases the overall surprisal of the suggestion (unless that
              next token follows the last 100% of the time). So, how do we
              prioritize longer, but more useful suggestions? Instead of
              sorting suggestions based on the surprisal of the entire
              suggestion, we'll sort it according to the average, or mean
              surprise of the entire suggestion. This means for single token
              suggestions, its surprisal doesn't change. But for multitoken
              suggestions, where some tokens contribute very little to the
              surprisal of the suggestion, the longer suggestion is given.

              $S_{i}$ is the rank of suggestion $i$. $I_{i}$ here is the
              surprisal of all of the tokens in this suggestion. Therefore,
              just divide the total of tokens in the suggestion and we get an
              arithmetic mean.

              (a thought occurs: do we want mean surprise or mean probability?
              Because, mean probability would require log transforming...).

              It's effectiveness is left as an exercise for the reader...
            </aside>
          </section>

        </section>

        <section>
          <section>
            <h2> Lessons Learned </h2>
          </section>
          <section>
            <h2> It's just JavaScript (&amp; npm!)</h2>

            <div class="fragment"></div>

            <aside class="notes">
              Atom Electron which is basically chromium mashed together with
              node.js.  It's pretty rad. I don't know enough about it to
              compare it with React Native, but they are similar.

              You can just use npm and `require` like normal, which grants you one of the
              best parts of javascript. Plus it has most front-end libraries,
              incluing React and jQuery.
            </aside>
          </section>

          <section>
            <h2> The Atom Community is... uh... </h2>

            <aside class="notes">
              Personal opinion time. The Atom community is kind of... weird.

              They have a style guide, but it lists what kind of emoji you
              SHOULD use in commit messages.

              They also want all of the code to be in CoffeeScript. I won't
              comment on CoffeeScript itself, but they're very insistent, to
              the point of starting flame wars on the Atom discussion threads.
              Note that this persists even in a post-ECMAScript 6 world.
            </aside>
          </section>

          <section>
            <h2> Relying on Pre 1.0 APIs </h2>
            <h3 class="fragment"> BAD IDEA </h3>

            <aside class="notes">
              I'd often get the rug pulled out underneath me as APIs were
              constantly changing. Not to mention the API docs were... lacking
              at best. I actually started a pull request to improve their docs
              for writing tests, and documenting the monkey-patching they did
              to make tests happen; but I ultimately did not complete it.

              At this point, I didn't know what React was, so I went ahead and
              modifed the DOM by hand. It's just JavaScript! But then they
              updated their React version which added aggressive checking of
              DOM invariants and inevitablly broke Gamboge. It has stayed in
              this state FOREVER.

              Speaking of tests.
            </aside>
          </section>

          <section>
            <h2> Asynchronous testing in Jasmine 1.x </h2>
            <h3 class="fragment"> BAD IDEA </h3>

            <aside class="notes"> In Atom, there's not good way to use any
              other testing framework than Jasmine 1.3. That's it. It's bundled
              in.  And it's pretty cool, that you can full script the editor.
              Really neat! But a lot of my tests involved asynchronous code.  Who
              has tested asynchronous code in Jasmine prior to version 1?  It's a
              bad idea. It's clunky, and problematic. And was the source of much
              frustration.
            </aside>
          </section>

        </section>

        <!-- Lessons learned -->
          <!-- What's great! -->
            <!-- It's just JavaScript & npm! -->
            <!-- Atom Electron! -->
          <!-- What's not so great... -->
            <!-- Async testing with Jasmine 1.3... -->
            <!-- The community... -->
            <!-- CoffeeScript -->
            <!-- Constantly shifting API and Atom devs' ADHD. -->
            <!-- React - I like react but... -->

        <!-- THE END -->
        <section>
          <section>
            <h2>Resources</h2>
            <h3> Natural Language Processing </h3>
            <ul>
              <li>
                <a href="https://class.coursera.org/nlp/lecture">Stanford NLP Lectures</a>
              </li>
              <li>
                <a href="https://github.com/NaturalNode/natural">NaturalNode</a>
              </li>
              <li>
                <a href="http://www.nltk.org/">NLTK (Python)</a>
              </li>
            </ul>
          </section>

          <section>
            <h2>Resources</h2>
            <h3> Language Tools </h3>
            <ul>
              <li>
                <a href="http://esprima.org/">Esprima</a>
              </li>
              <li>
                <a href="https://github.com/estools/escodegen">escodegen</a>
              </li>
            </ul>
          </section>
        </section>

        <section>
          <h2> Special Thanks </h2>
          <ul>
            <li><a href="http://softwareprocess.es/">Abram Hindle</a></li>
            <li><a href="http://orezpraw.com/">Joshua Charles Campbell</a></li>
            <li><a href="http://hipposociety.com/">Alex Wilson</a></li>
          </ul>
        </section>
      </div>
    </div>


    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: false,
      progress: false,
      history: true,
      center: true,

      transition: 'slide', // none/fade/slide/convex/concave/zoom

      // Optional reveal.js plugins
      dependencies: [
        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: 'plugin/zoom-js/zoom.js', async: true },
        { src: 'plugin/notes/notes.js', async: true },
        // MathJax
        { src: 'plugin/math/math.js', async: true }
      ]
    });

    </script>

  </body>
</html>
